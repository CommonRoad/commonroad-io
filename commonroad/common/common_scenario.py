import enum
import warnings
from typing import Union

from numpy import double

from commonroad.common.util import Time


class ScenarioMetaInformation:
    """
    Class that contains meta information regarding the new format scenario
    """

    def __init__(self, commonroad_version: str, benchmark_id: str, date: Time, author: str, affiliation: str,
                 source: str, time_step_size: double, license_name: str, license_text: str = None):
        """
        :param commonroad_version: CommonRoad version of the scenario
        :param benchmark_id: unique CommonRoad benchmark ID of the scenario
        :param date: date of the scenario
        :param author: authors of the CommonRoad scenario
        :param affiliation: institution of the authors
        :param source: source of the scenario, e.g. generated by a map converter and a traffic simulator
        :param time_step_size: global time step size of the time-discrete scenario
        :param license_name: license name of the scenario
        :param license_text: license text of the scenario
        """
        self._commonroad_version = commonroad_version
        self._benchmark_id = benchmark_id
        self._date = date
        self._author = author
        self._affiliation = affiliation
        self._source = source
        self._time_step_size = time_step_size
        self._license_name = license_name
        if license_text is None:
            self._license_name = ""
        else:
            self._license_text = license_text

    def __eq__(self, other):
        if not isinstance(other, ScenarioMetaInformation):
            warnings.warn(f"Inequality between ScenarioMetaInformation {repr(self)} and different type {type(other)}")
            return False

        return self._commonroad_version == other.commonroad_version and self._benchmark_id == other.benchmark_id and \
            self._license_name == other.license_name and self._license_text == other.license_text and \
            self._date == other.date and self._author == other.author and self._affiliation == other.affiliation and \
            self._source == other.source and self._time_step_size == other.time_step_size

    def __hash__(self):
        return hash((self._commonroad_version, self._benchmark_id, self._date, self._author, self._affiliation,
                     self._source, self._time_step_size, self._license_name, self._license_text))

    @property
    def commonroad_version(self) -> str:
        """ CommonRoad version of the scenario."""
        return self._commonroad_version

    @commonroad_version.setter
    def commonroad_version(self, commonroad_version: str):
        self._commonroad_version = commonroad_version

    @property
    def benchmark_id(self) -> str:
        """ unique CommonRoad benchmark ID of the scenario"""
        return self._benchmark_id

    @benchmark_id.setter
    def benchmark_id(self, benchmark_id: str):
        self._benchmark_id = benchmark_id

    @property
    def license_name(self) -> str:
        """ license name of the scenario."""
        return self._license_name

    @license_name.setter
    def license_name(self, license_name: str):
        self._license_name = license_name

    @property
    def license_text(self) -> Union[None, str]:
        """ license text of the scenario."""
        return self._license_text

    @license_text.setter
    def license_text(self, license_text: Union[None, str]):
        if license_text is None:
            self._license_name = ""
        else:
            self._license_text = license_text

    @property
    def date(self) -> Time:
        """ date of the scenario."""
        return self._date

    @date.setter
    def date(self, date: Time):
        self._date = date

    @property
    def author(self) -> str:
        """ authors of the CommonRoad scenario."""
        return self._author

    @author.setter
    def author(self, author: str):
        self._author = author

    @property
    def affiliation(self) -> str:
        """ institution of the authors."""
        return self._affiliation

    @affiliation.setter
    def affiliation(self, affiliation: str):
        self._affiliation = affiliation

    @property
    def source(self) -> str:
        """ source of the scenario, e.g. generated by a map converter and a traffic simulator."""
        return self._source

    @source.setter
    def source(self, source: str):
        self._source = source

    @property
    def time_step_size(self) -> double:
        """ global time step size of the time-discrete scenario."""
        return self._time_step_size

    @time_step_size.setter
    def time_step_size(self, time_step_size: double):
        self._time_step_size = time_step_size


@enum.unique
class TimeOfDay(enum.Enum):
    """ Enum containing all possible time of days."""
    NIGHT = "night"
    SUNSET = "sunset"
    AFTERNOON = "afternoon"
    NOON = "noon"
    MORNING = "morning"
    UNKNOWN = "unknown"


@enum.unique
class Weather(enum.Enum):
    """ Enum containing all possible weathers."""
    CLEAR = "clear"
    LIGHT_RAIN = "light_rain"
    MID_RAIN = "mid_rain"
    HEAVY_RAIN = "heavy_rain"
    FOG = "fog"
    SNOW = "snow"
    HAIL = "hail"
    CLOUDY = "cloudy"
    UNKNOWN = "unknown"


@enum.unique
class Underground(enum.Enum):
    """ Enum containing all possible undergrounds."""
    WET = "wet"
    CLEAN = "clean"
    DIRTY = "dirty"
    DAMAGED = "damaged"
    SNOW = "snow"
    ICE = "ice"
    UNKNOWN = "unknown"


class Environment:
    """
    Class which describes the environment where a scenario takes place as specified in the CommonRoad specification.
    """

    def __init__(self, time: Time = None, time_of_day: TimeOfDay = None, weather: Weather = None,
                 underground: Underground = None):
        """
        Constructor of an environment object

        :param time: time in hours
        :param time_of_day: current time of day, i.e., day or night
        :param weather: weather information, e.g., sunny
        :param underground: underground information, e.g., ice
        """
        self._time = time
        self._time_of_day = time_of_day
        self._weather = weather
        self._underground = underground

    def __eq__(self, other):
        if not isinstance(other, Environment):
            return False

        return self._time == other.time and self._time_of_day == other.time_of_day and \
            self._weather == other.weather and self._underground == other.underground

    def __hash__(self):
        return hash((self._time, self._time_of_day, self._weather, self._underground))

    @property
    def time(self) -> Time:
        return self._time

    @time.setter
    def time(self, time: Time):
        self._time = time

    @property
    def time_of_day(self) -> TimeOfDay:
        return self._time_of_day

    @time_of_day.setter
    def time_of_day(self, time_of_day: TimeOfDay):
        self._time_of_day = time_of_day

    @property
    def weather(self) -> Weather:
        return self._weather

    @weather.setter
    def weather(self, weather: Weather):
        self._weather = weather

    @property
    def underground(self) -> Underground:
        return self._underground

    @underground.setter
    def underground(self, underground: Underground):
        self._underground = underground


class GeoTransformation:
    """
    Class which describes the transformation from geodetic to projected Cartesian coordinates according to the
    CommonRoad specification
    """

    def __init__(self, geo_reference: str = None, x_translation: float = None, y_translation: float = None,
                 z_rotation: float = None, scaling: float = None):
        """
        Constructor of a location object

        :param geo_reference: proj-string describing transformation from geodetic to projected Cartesian coordinates
        :param x_translation: translation value for x-coordinates
        :param y_translation: translation value for y-coordinates
        :param z_rotation: rotation value around origin
        :param scaling: multiplication value of x- and y-coordinates
        """
        self.geo_reference = geo_reference
        self.x_translation = x_translation
        self.y_translation = y_translation
        self.z_rotation = z_rotation
        self.scaling = scaling

    def __eq__(self, other):
        if not isinstance(other, GeoTransformation):
            return False

        return self._geo_reference == other.geo_reference and self._x_translation == other.x_translation and \
            self._y_translation == other.y_translation and self._z_rotation == other.z_rotation and \
            self._scaling == other.scaling

    def __hash__(self):
        return hash((self._geo_reference, self._x_translation, self._y_translation, self._z_rotation, self._scaling))

    @property
    def geo_reference(self) -> str:
        return self._geo_reference

    @property
    def x_translation(self) -> float:
        return self._x_translation

    @property
    def y_translation(self) -> float:
        return self._y_translation

    @property
    def z_rotation(self) -> float:
        return self._z_rotation

    @property
    def scaling(self) -> float:
        return self._scaling

    @geo_reference.setter
    def geo_reference(self, geo_reference):
        self._geo_reference = geo_reference if geo_reference is not None else 0

    @x_translation.setter
    def x_translation(self, x_translation):
        self._x_translation = x_translation if x_translation is not None else 0

    @y_translation.setter
    def y_translation(self, y_translation):
        self._y_translation = y_translation if y_translation is not None else 0

    @z_rotation.setter
    def z_rotation(self, z_rotation):
        self._z_rotation = z_rotation if z_rotation is not None else 0

    @scaling.setter
    def scaling(self, scaling):
        self._scaling = scaling if scaling is not None else 1


class Location:
    """
    Class which describes a location according to the CommonRoad specification.
    """

    def __init__(self, geo_name_id: int = -999, gps_latitude: float = 999, gps_longitude: float = 999,
                 geo_transformation: GeoTransformation = None, environment: Environment = None):
        """
        Constructor of a location object

        :param geo_name_id: GeoName ID
        :param gps_latitude: GPS latitude coordinate
        :param gps_longitude: GPS longitude coordinate
        :param geo_transformation: description of geometric transformation during scenario generation
        :param environment: environmental information, e.g. weather
        """
        self._geo_name_id = geo_name_id
        self._gps_latitude = gps_latitude
        self._gps_longitude = gps_longitude
        self._geo_transformation = geo_transformation
        self._environment = environment

    def __eq__(self, other):
        if not isinstance(other, Location):
            return False

        return self._geo_name_id == other.geo_name_id and self._gps_latitude == other.gps_latitude and \
            self._gps_longitude == other.gps_longitude and self._geo_transformation == other.geo_transformation and \
            self._environment == other.environment

    def __hash__(self):
        return hash((self._geo_name_id, self._gps_latitude, self._gps_longitude, self._geo_transformation,
                     self._environment))

    @property
    def geo_name_id(self) -> int:
        return self._geo_name_id

    @geo_name_id.setter
    def geo_name_id(self, geo_name_id: int):
        self._geo_name_id = geo_name_id

    @property
    def gps_latitude(self) -> float:
        return self._gps_latitude

    @gps_latitude.setter
    def gps_latitude(self, gps_latitude: float):
        self._gps_latitude = gps_latitude

    @property
    def gps_longitude(self) -> float:
        return self._gps_longitude

    @gps_longitude.setter
    def gps_longitude(self, gps_longitude: float):
        self._gps_longitude = gps_longitude

    @property
    def geo_transformation(self) -> GeoTransformation:
        return self._geo_transformation

    @geo_transformation.setter
    def geo_transformation(self, geo_transformation: GeoTransformation):
        self._geo_transformation = geo_transformation

    @property
    def environment(self) -> Environment:
        return self._environment

    @environment.setter
    def environment(self, environment: Environment):
        self._environment = environment
