<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>commonroad.scenario.lanelet &mdash; CommonRoad_io 2022.3 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> CommonRoad_io
            <img src="../../../_static/commonroad_white150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2022.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../user/getting_started.html">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user/getting_started.html#reading-files">Reading Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/getting_started.html#scenario">Scenario</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user/getting_started.html#lanelet-network">Lanelet Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/getting_started.html#obstacles">Obstacles</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/getting_started.html#dynamic-obstacle-prediction">Dynamic Obstacle Prediction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user/getting_started.html#trajectory-prediction">Trajectory Prediction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user/getting_started.html#set-based-prediction">Set Based Prediction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/getting_started.html#planning-problems">Planning Problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/getting_started.html#writing-files">Writing Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/getting_started.html#solution-writer">Solution Writer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../user/visualization.html">Visualization Manual</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user/visualization.html#creating-plots-in-commonroad">Creating plots in CommonRoad</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/visualization.html#styling-options">Styling options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user/visualization.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user/visualization.html#plot-limits"><code class="docutils literal notranslate"><span class="pre">plot_limits</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">CommonRoad_io API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/index.html#modules">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/scenario.html">Module Scenario</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#module-commonroad.scenario.scenario">Scenario</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#module-commonroad.scenario.lanelet">Road network</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#module-commonroad.scenario.traffic_sign">Traffic Sign</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#traffic-light">Traffic Light</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#module-commonroad.scenario.traffic_sign_interpreter">Traffic Sign Interpreter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#intersection">Intersection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#obstacles">Obstacles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#module-commonroad.scenario.trajectory">Trajectories</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/scenario.html#module-commonroad.scenario.state">States</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/prediction.html">Module Prediction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/prediction.html#prediction-class"><code class="docutils literal notranslate"><span class="pre">Prediction</span></code> class</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/prediction.html#trajectoryprediction-class"><code class="docutils literal notranslate"><span class="pre">TrajectoryPrediction</span></code> class</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/prediction.html#setbasedprediction-class"><code class="docutils literal notranslate"><span class="pre">SetBasedPrediction</span></code> class</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/prediction.html#occupancy-class"><code class="docutils literal notranslate"><span class="pre">Occupancy</span></code> class</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/planning.html">Module Planning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/planning.html#module-commonroad.planning.planning_problem">Planning Problem</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/planning.html#module-commonroad.planning.goal">Goal Region</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/geometry.html">Module Geometry</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/geometry.html#module-commonroad.geometry.shape">Shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/geometry.html#module-geometry.transform">Transform</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/geometry.html#module-geometry.polyline_util">Polyline Utility Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/common.html">Module Common</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/common.html#module-commonroad.common.file_reader">File Reader</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/common.html#module-commonroad.common.file_writer">File Writer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/common.html#solution-reader-and-writer">Solution Reader and Writer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/common.html#module-commonroad.common.util">Util</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/visualization.html">Module Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/visualization.html#module-commonroad.visualization.drawable">Drawing interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/visualization.html#module-commonroad.visualization.draw_params">Drawing parameters</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CommonRoad_io</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">commonroad.scenario.lanelet</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for commonroad.scenario.lanelet</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span> <span class="k">as</span> <span class="n">ShapelyPoint</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span> <span class="k">as</span> <span class="n">ShapelyPolygon</span>
<span class="kn">from</span> <span class="nn">shapely.strtree</span> <span class="kn">import</span> <span class="n">STRtree</span>

<span class="kn">import</span> <span class="nn">commonroad.geometry.transform</span>
<span class="kn">from</span> <span class="nn">commonroad.common.util</span> <span class="kn">import</span> <span class="n">subtract_orientations</span>
<span class="kn">from</span> <span class="nn">commonroad.common.validity</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">commonroad.geometry.shape</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">ShapeGroup</span><span class="p">,</span> <span class="n">Circle</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">,</span> <span class="n">Shape</span>
<span class="kn">from</span> <span class="nn">commonroad.scenario.intersection</span> <span class="kn">import</span> <span class="n">Intersection</span>
<span class="kn">from</span> <span class="nn">commonroad.scenario.obstacle</span> <span class="kn">import</span> <span class="n">Obstacle</span>
<span class="kn">from</span> <span class="nn">commonroad.scenario.state</span> <span class="kn">import</span> <span class="n">TraceState</span>
<span class="kn">from</span> <span class="nn">commonroad.scenario.traffic_sign</span> <span class="kn">import</span> <span class="n">TrafficSign</span><span class="p">,</span> <span class="n">TrafficLight</span>
<span class="kn">from</span> <span class="nn">commonroad.visualization.drawable</span> <span class="kn">import</span> <span class="n">IDrawable</span>
<span class="kn">from</span> <span class="nn">commonroad.visualization.renderer</span> <span class="kn">import</span> <span class="n">IRenderer</span>
<span class="kn">from</span> <span class="nn">commonroad.visualization.draw_params</span> <span class="kn">import</span> <span class="n">OptionalSpecificOrAllDrawParams</span><span class="p">,</span> <span class="n">LaneletNetworkParams</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Christian Pek, Sebastian Maierhofer&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;TUM Cyber-Physical Systems Group&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BMW CAR@TUM&quot;</span><span class="p">]</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;2022.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Sebastian Maierhofer&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;commonroad@lists.lrz.de&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;released&quot;</span>


<span class="k">class</span> <span class="nc">LineMarking</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enum describing different types of line markings, i.e. dashed or solid lines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DASHED</span> <span class="o">=</span> <span class="s1">&#39;dashed&#39;</span>
    <span class="n">SOLID</span> <span class="o">=</span> <span class="s1">&#39;solid&#39;</span>
    <span class="n">BROAD_DASHED</span> <span class="o">=</span> <span class="s1">&#39;broad_dashed&#39;</span>
    <span class="n">BROAD_SOLID</span> <span class="o">=</span> <span class="s1">&#39;broad_solid&#39;</span>
    <span class="n">UNKNOWN</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>
    <span class="n">NO_MARKING</span> <span class="o">=</span> <span class="s1">&#39;no_marking&#39;</span>


<div class="viewcode-block" id="LaneletType"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletType">[docs]</a><span class="k">class</span> <span class="nc">LaneletType</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enum describing different types of lanelets</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">URBAN</span> <span class="o">=</span> <span class="s1">&#39;urban&#39;</span>
    <span class="n">COUNTRY</span> <span class="o">=</span> <span class="s1">&#39;country&#39;</span>
    <span class="n">HIGHWAY</span> <span class="o">=</span> <span class="s1">&#39;highway&#39;</span>
    <span class="n">DRIVE_WAY</span> <span class="o">=</span> <span class="s1">&#39;driveWay&#39;</span>
    <span class="n">MAIN_CARRIAGE_WAY</span> <span class="o">=</span> <span class="s1">&#39;mainCarriageWay&#39;</span>
    <span class="n">ACCESS_RAMP</span> <span class="o">=</span> <span class="s1">&#39;accessRamp&#39;</span>
    <span class="n">EXIT_RAMP</span> <span class="o">=</span> <span class="s1">&#39;exitRamp&#39;</span>
    <span class="n">SHOULDER</span> <span class="o">=</span> <span class="s1">&#39;shoulder&#39;</span>
    <span class="n">BUS_LANE</span> <span class="o">=</span> <span class="s1">&#39;busLane&#39;</span>
    <span class="n">BUS_STOP</span> <span class="o">=</span> <span class="s1">&#39;busStop&#39;</span>
    <span class="n">BICYCLE_LANE</span> <span class="o">=</span> <span class="s1">&#39;bicycleLane&#39;</span>
    <span class="n">SIDEWALK</span> <span class="o">=</span> <span class="s1">&#39;sidewalk&#39;</span>
    <span class="n">CROSSWALK</span> <span class="o">=</span> <span class="s1">&#39;crosswalk&#39;</span>
    <span class="n">INTERSTATE</span> <span class="o">=</span> <span class="s1">&#39;interstate&#39;</span>
    <span class="n">INTERSECTION</span> <span class="o">=</span> <span class="s1">&#39;intersection&#39;</span>
    <span class="n">BORDER</span> <span class="o">=</span> <span class="s1">&#39;border&#39;</span>
    <span class="n">PARKING</span> <span class="o">=</span> <span class="s1">&#39;parking&#39;</span>
    <span class="n">RESTRICTED</span> <span class="o">=</span> <span class="s1">&#39;restricted&#39;</span>  <span class="c1"># cars not allowed, e.g., special lanes for busses</span>
    <span class="n">UNKNOWN</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span></div>


<div class="viewcode-block" id="RoadUser"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.RoadUser">[docs]</a><span class="k">class</span> <span class="nc">RoadUser</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enum describing different types of road users</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">VEHICLE</span> <span class="o">=</span> <span class="s1">&#39;vehicle&#39;</span>
    <span class="n">CAR</span> <span class="o">=</span> <span class="s1">&#39;car&#39;</span>
    <span class="n">TRUCK</span> <span class="o">=</span> <span class="s1">&#39;truck&#39;</span>
    <span class="n">BUS</span> <span class="o">=</span> <span class="s1">&#39;bus&#39;</span>
    <span class="n">PRIORITY_VEHICLE</span> <span class="o">=</span> <span class="s1">&#39;priorityVehicle&#39;</span>
    <span class="n">MOTORCYCLE</span> <span class="o">=</span> <span class="s1">&#39;motorcycle&#39;</span>
    <span class="n">BICYCLE</span> <span class="o">=</span> <span class="s1">&#39;bicycle&#39;</span>
    <span class="n">PEDESTRIAN</span> <span class="o">=</span> <span class="s1">&#39;pedestrian&#39;</span>
    <span class="n">TRAIN</span> <span class="o">=</span> <span class="s1">&#39;train&#39;</span>
    <span class="n">TAXI</span> <span class="o">=</span> <span class="s1">&#39;taxi&#39;</span></div>


<span class="k">class</span> <span class="nc">StopLine</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class which describes the stop line of a lanelet&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">line_marking</span><span class="p">:</span> <span class="n">LineMarking</span><span class="p">,</span> <span class="n">traffic_sign_ref</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">traffic_light_ref</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking</span> <span class="o">=</span> <span class="n">line_marking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_sign_ref</span> <span class="o">=</span> <span class="n">traffic_sign_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_light_ref</span> <span class="o">=</span> <span class="n">traffic_light_ref</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">StopLine</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality between StopLine </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and different type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">prec</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">start_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">prec</span><span class="p">)</span>
        <span class="n">start_other_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">prec</span><span class="p">)</span>
        <span class="n">end_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">prec</span><span class="p">)</span>
        <span class="n">end_other_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">prec</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_string</span> <span class="o">==</span> <span class="n">start_other_string</span> <span class="ow">and</span> <span class="n">end_string</span> <span class="o">==</span> <span class="n">end_other_string</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking</span> <span class="o">==</span> \
                <span class="n">other</span><span class="o">.</span><span class="n">line_marking</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_sign_ref</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">traffic_sign_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_light_ref</span> \
                <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">traffic_light_ref</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality of StopLine </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and the other one </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_string</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="mi">10</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_string</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="mi">10</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">sign_ref</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_sign_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_sign_ref</span><span class="p">)</span>
        <span class="n">light_ref</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_light_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_light_ref</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="n">start_string</span><span class="p">,</span> <span class="n">end_string</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking</span><span class="p">,</span> <span class="n">sign_ref</span><span class="p">,</span> <span class="n">light_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;StopLine from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;StopLine(start=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">, end=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">, line_marking=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_line_marking</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;traffic_sign_ref=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_sign_ref</span><span class="si">}</span><span class="s2">, traffic_light_ref=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_light_ref</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

    <span class="nd">@start</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span>

    <span class="nd">@end</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">line_marking</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineMarking</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking</span>

    <span class="nd">@line_marking</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">line_marking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marking</span><span class="p">:</span> <span class="n">LineMarking</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking</span> <span class="o">=</span> <span class="n">marking</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traffic_sign_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_sign_ref</span>

    <span class="nd">@traffic_sign_ref</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">traffic_sign_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">references</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_sign_ref</span> <span class="o">=</span> <span class="n">references</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traffic_light_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_light_ref</span>

    <span class="nd">@traffic_light_ref</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">traffic_light_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">references</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_light_ref</span> <span class="o">=</span> <span class="n">references</span>

    <span class="k">def</span> <span class="nf">translate_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method translates and rotates a stop line</span>

<span class="sd">        :param translation: The translation given as [x_off,y_off] for the x and y translation</span>
<span class="sd">        :param angle: The rotation angle in radian (counter-clockwise defined)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">is_real_number_vector</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/translate_rotate&gt;: provided translation &#39;</span> \
                                                      <span class="s1">&#39;is not valid! translation = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">is_valid_orientation</span><span class="p">(</span>
                <span class="n">angle</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/translate_rotate&gt;: provided angle is not valid! angle = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

        <span class="c1"># create transformation matrix</span>
        <span class="n">t_m</span> <span class="o">=</span> <span class="n">commonroad</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">translation_rotation_matrix</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">line_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">])</span>
        <span class="c1"># transform center vertices</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">t_m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">line_vertices</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">line_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))))</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<div class="viewcode-block" id="Lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet">[docs]</a><span class="k">class</span> <span class="nc">Lanelet</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class which describes a Lanelet entity according to the CommonRoad specification. Each lanelet is described by a</span>
<span class="sd">    left and right boundary (polylines). Furthermore, lanelets have relations to other lanelets, e.g. an adjacent left</span>
<span class="sd">    neighbor or a predecessor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">center_vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">right_vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">lanelet_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">predecessor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">successor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adjacent_left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">adjacent_left_same_direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adjacent_right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adjacent_right_same_direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">line_marking_left_vertices</span><span class="o">=</span><span class="n">LineMarking</span><span class="o">.</span><span class="n">NO_MARKING</span><span class="p">,</span> <span class="n">line_marking_right_vertices</span><span class="o">=</span><span class="n">LineMarking</span><span class="o">.</span><span class="n">NO_MARKING</span><span class="p">,</span>
                 <span class="n">stop_line</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lanelet_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">user_one_way</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">user_bidirectional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">traffic_signs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">traffic_lights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of a Lanelet object</span>
<span class="sd">        :param left_vertices: The vertices of the left boundary of the Lanelet described as a</span>
<span class="sd">        polyline [[x0,y0],[x1,y1],...,[xn,yn]]</span>
<span class="sd">        :param center_vertices: The vertices of the center line of the Lanelet described as a</span>
<span class="sd">        polyline [[x0,y0],[x1,y1],...,[xn,yn]]</span>
<span class="sd">        :param right_vertices: The vertices of the right boundary of the Lanelet described as a</span>
<span class="sd">        polyline [[x0,y0],[x1,y1],...,[xn,yn]]</span>
<span class="sd">        :param lanelet_id: The unique id (natural number) of the lanelet</span>
<span class="sd">        :param predecessor: The list of predecessor lanelets (None if not existing)</span>
<span class="sd">        :param successor: The list of successor lanelets (None if not existing)</span>
<span class="sd">        :param adjacent_left: The adjacent left lanelet (None if not existing)</span>
<span class="sd">        :param adjacent_left_same_direction: True if the adjacent left lanelet has the same driving direction,</span>
<span class="sd">        false otherwise (None if no left adjacent lanelet exists)</span>
<span class="sd">        :param adjacent_right: The adjacent right lanelet (None if not existing)</span>
<span class="sd">        :param adjacent_right_same_direction: True if the adjacent right lanelet has the same driving direction,</span>
<span class="sd">        false otherwise (None if no right adjacent lanelet exists)</span>
<span class="sd">        :param line_marking_left_vertices: The type of line marking of the left boundary</span>
<span class="sd">        :param line_marking_right_vertices: The type of line marking of the right boundary</span>
<span class="sd">        :param stop_line: The stop line of the lanelet</span>
<span class="sd">        :param lanelet_type: The types of lanelet applicable here</span>
<span class="sd">        :param user_one_way: type of users that will use the lanelet as one-way</span>
<span class="sd">        :param user_bidirectional: type of users that will use the lanelet as bidirectional way</span>
<span class="sd">        :param traffic_signs: Traffic signs to be applied</span>
<span class="sd">        :param traffic_lights: Traffic lights to follow</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set required properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="o">=</span> <span class="n">lanelet_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_vertices</span> <span class="o">=</span> <span class="n">left_vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_vertices</span> <span class="o">=</span> <span class="n">right_vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span> <span class="o">=</span> <span class="n">center_vertices</span>
        <span class="c1"># check if length of each polyline is the same</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">center_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">right_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;&lt;Lanelet/init&gt;: Provided polylines do not share the same length! </span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">left_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">center_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Set lane markings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_left_vertices</span> <span class="o">=</span> <span class="n">line_marking_left_vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_right_vertices</span> <span class="o">=</span> <span class="n">line_marking_right_vertices</span>

        <span class="c1"># Set predecessors and successors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">predecessor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predecessor</span> <span class="o">=</span> <span class="n">predecessor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_successor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">successor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_successor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">successor</span> <span class="o">=</span> <span class="n">successor</span>

        <span class="c1"># Set adjacent lanelets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left_same_direction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">adjacent_left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_left</span> <span class="o">=</span> <span class="n">adjacent_left</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_left_same_direction</span> <span class="o">=</span> <span class="n">adjacent_left_same_direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right_same_direction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">adjacent_right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_right</span> <span class="o">=</span> <span class="n">adjacent_right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_right_same_direction</span> <span class="o">=</span> <span class="n">adjacent_right_same_direction</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inner_distance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># create empty polygon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">right_vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_obstacles_on_lanelet</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_obstacles_on_lanelet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stop_line</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stop_line</span> <span class="o">=</span> <span class="n">stop_line</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">lanelet_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_type</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lanelet_type</span> <span class="o">=</span> <span class="n">lanelet_type</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_one_way</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">user_one_way</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_one_way</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_one_way</span> <span class="o">=</span> <span class="n">user_one_way</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bidirectional</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">user_bidirectional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_bidirectional</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_bidirectional</span> <span class="o">=</span> <span class="n">user_bidirectional</span>

        <span class="c1"># Set Traffic Rules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">traffic_signs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traffic_signs</span> <span class="o">=</span> <span class="n">traffic_signs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">traffic_lights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traffic_lights</span> <span class="o">=</span> <span class="n">traffic_lights</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Lanelet</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality between Lanelet </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and different type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">list_elements_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">stop_line</span>

        <span class="n">lanelet_eq</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">polylines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span><span class="p">]</span>
        <span class="n">polylines_other</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">right_vertices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polylines</span><span class="p">)):</span>
            <span class="n">polyline</span> <span class="o">=</span> <span class="n">polylines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">polyline_other</span> <span class="o">=</span> <span class="n">polylines_other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">polyline_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="mi">10</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">polyline_other_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">polyline_other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="mi">10</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">lanelet_eq</span> <span class="o">=</span> <span class="n">lanelet_eq</span> <span class="ow">and</span> <span class="n">polyline_string</span> <span class="o">==</span> <span class="n">polyline_other_string</span>

        <span class="k">if</span> <span class="n">lanelet_eq</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_left_vertices</span> <span class="o">==</span> \
                <span class="n">other</span><span class="o">.</span><span class="n">line_marking_left_vertices</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_right_vertices</span> <span class="o">==</span> \
                <span class="n">other</span><span class="o">.</span><span class="n">line_marking_right_vertices</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">predecessor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_successor</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">successor</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">adj_left</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">adj_right</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left_same_direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">adj_left_same_direction</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right_same_direction</span> <span class="o">==</span> \
                <span class="n">other</span><span class="o">.</span><span class="n">adj_right_same_direction</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lanelet_type</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_one_way</span> <span class="o">==</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">user_one_way</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bidirectional</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">user_bidirectional</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span> <span class="o">==</span>\
                <span class="n">other</span><span class="o">.</span><span class="n">traffic_signs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">traffic_lights</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">list_elements_eq</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality of Lanelet </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and the other one </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">polylines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span><span class="p">]</span>
        <span class="n">polyline_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="n">polylines</span><span class="p">:</span>
            <span class="n">polyline_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="mi">10</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">polyline_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polyline_string</span><span class="p">)</span>

        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_successor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_one_way</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_user_bidirectional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">]</span>
        <span class="n">frozen_elements</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">polyline_strings</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_left_vertices</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_right_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left_same_direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right_same_direction</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frozen_elements</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Lanelet with id </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span><span class="si">}</span><span class="s2"> has predecessors </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span><span class="p">)</span><span class="si">}</span><span class="s2">, successors &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_successor</span><span class="p">)</span><span class="si">}</span><span class="s2">, left adjacency </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_adj_left</span><span class="si">}</span><span class="s2"> with &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;same&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left_same_direction</span> <span class="k">else</span> <span class="s1">&#39;opposite&#39;</span><span class="si">}</span><span class="s2"> direction, and &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;right adjacency with </span><span class="si">{</span><span class="s1">&#39;same&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right_same_direction</span> <span class="k">else</span> <span class="s1">&#39;opposite&#39;</span><span class="si">}</span><span class="s2"> direction&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Lanelet(left_vertices=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;center_vertices=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;right_vertices=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">, lanelet_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;predecessor=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span><span class="si">}</span><span class="s2">, successor=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_successor</span><span class="si">}</span><span class="s2">, adjacent_left=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_adj_left</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;adjacent_left_same_direction=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_adj_left_same_direction</span><span class="si">}</span><span class="s2">, adjacent_right=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_adj_right</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;adjacent_right_same_direction=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_adj_right_same_direction</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;line_marking_left_vertices=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_left_vertices</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;line_marking_right_vertices=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_right_vertices</span><span class="si">}</span><span class="s2">), &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;stop_line=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span><span class="p">)</span><span class="si">}</span><span class="s2">, lanelet_type=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_type</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;user_one_way=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_user_one_way</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;user_bidirectional=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_user_bidirectional</span><span class="si">}</span><span class="s2">, traffic_signs=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;traffic_lights=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns cumulative distance along center vertices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_polyline_cumsum_dist</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

    <span class="nd">@distance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inner_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns minimum cumulative distance along left and right vertices, i.e., along the inner curve:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inner_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_polyline_cumsum_dist</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_vertices</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lanelet_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span>

    <span class="nd">@lanelet_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lanelet_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">is_natural_number</span><span class="p">(</span><span class="n">l_id</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/lanelet_id&gt;: Provided lanelet_id is not valid! id=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span> <span class="o">=</span> <span class="n">l_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span>

    <span class="nd">@left_vertices</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">left_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyline</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the left vertices are strongly modified, the STRtree cannot be valid anymore!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_valid_polyline</span><span class="p">(</span><span class="n">polyline</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/left_vertices&gt;: The provided polyline &#39;</span> \
                                            <span class="s1">&#39;is not valid! id = </span><span class="si">{}</span><span class="s1"> polyline = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span><span class="p">,</span> <span class="n">polyline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span> <span class="o">=</span> <span class="n">polyline</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span>

    <span class="nd">@right_vertices</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">right_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyline</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the right vertices are strongly modified, the STRtree cannot be valid anymore!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_valid_polyline</span><span class="p">(</span><span class="n">polyline</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/right_vertices&gt;: The provided polyline &#39;</span> \
                                            <span class="s1">&#39;is not valid! id = </span><span class="si">{}</span><span class="s1">, polyline = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id</span><span class="p">,</span> <span class="n">polyline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span> <span class="o">=</span> <span class="n">polyline</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compute_polyline_cumsum_dist</span><span class="p">(</span><span class="n">polylines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">comparator</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="n">polylines</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">polyline</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">segment_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">polylines</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">polylines</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d_tmp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">segment_distances</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">d_tmp</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">comparator</span><span class="p">(</span><span class="n">segment_distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span>

    <span class="nd">@center_vertices</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">center_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyline</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">is_valid_polyline</span><span class="p">(</span>
            <span class="n">polyline</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/center_vertices&gt;: The provided polyline is not valid! polyline = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span> <span class="o">=</span> <span class="n">polyline</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">line_marking_left_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineMarking</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_left_vertices</span>

    <span class="nd">@line_marking_left_vertices</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">line_marking_left_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_marking_left_vertices</span><span class="p">:</span> <span class="n">LineMarking</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_marking_left_vertices</span><span class="p">,</span>
                          <span class="n">LineMarking</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/line_marking_left_vertices&gt;: Provided lane marking type of &#39;</span> \
                                        <span class="s1">&#39;left boundary is not valid! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line_marking_left_vertices</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_left_vertices</span> <span class="o">=</span> <span class="n">line_marking_left_vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">line_marking_right_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineMarking</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_right_vertices</span>

    <span class="nd">@line_marking_right_vertices</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">line_marking_right_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_marking_right_vertices</span><span class="p">:</span> <span class="n">LineMarking</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_marking_right_vertices</span><span class="p">,</span>
                          <span class="n">LineMarking</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/line_marking_right_vertices&gt;: Provided lane marking type of &#39;</span> \
                                        <span class="s1">&#39;right boundary is not valid! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">line_marking_right_vertices</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_marking_right_vertices</span> <span class="o">=</span> <span class="n">line_marking_right_vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predecessor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span>

    <span class="nd">@predecessor</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">predecessor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predecessor</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">is_list_of_natural_numbers</span><span class="p">(</span><span class="n">predecessor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">predecessor</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> \
            <span class="s1">&#39;&lt;Lanelet/predecessor&gt;: Provided list of predecessors is not valid! predecessors = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">predecessor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predecessor</span> <span class="o">=</span> <span class="n">predecessor</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">successor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_successor</span>

    <span class="nd">@successor</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">successor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">successor</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">is_list_of_natural_numbers</span><span class="p">(</span><span class="n">successor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">successor</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/predecessor&gt;: Provided list of successors is not valid! successors = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">successor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_successor</span> <span class="o">=</span> <span class="n">successor</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adj_left</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left</span>

    <span class="nd">@adj_left</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">adj_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left</span> <span class="o">=</span> <span class="n">l_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adj_left_same_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left_same_direction</span>

    <span class="nd">@adj_left_same_direction</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">adj_left_same_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">same</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/adj_left_same_direction&gt;: provided direction &#39;</span> \
                                       <span class="s1">&#39;is not of type bool! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">same</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_left_same_direction</span> <span class="o">=</span> <span class="n">same</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adj_right</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right</span>

    <span class="nd">@adj_right</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">adj_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right</span> <span class="o">=</span> <span class="n">l_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adj_right_same_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right_same_direction</span>

    <span class="nd">@adj_right_same_direction</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">adj_right_same_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">same</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/adj_right_same_direction&gt;: provided direction &#39;</span> \
                                       <span class="s1">&#39;is not of type bool! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">same</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adj_right_same_direction</span> <span class="o">=</span> <span class="n">same</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dynamic_obstacles_on_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_obstacles_on_lanelet</span>

    <span class="nd">@dynamic_obstacles_on_lanelet</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dynamic_obstacles_on_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacle_ids</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obstacle_ids</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/obstacles_on_lanelet&gt;: provided dictionary of ids is not a &#39;</span> \
                                               <span class="s1">&#39;dictionary! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obstacle_ids</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_obstacles_on_lanelet</span> <span class="o">=</span> <span class="n">obstacle_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">static_obstacles_on_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_obstacles_on_lanelet</span>

    <span class="nd">@static_obstacles_on_lanelet</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">static_obstacles_on_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacle_ids</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obstacle_ids</span><span class="p">,</span> <span class="nb">set</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/obstacles_on_lanelet&gt;: provided list of ids is not a &#39;</span> \
                                              <span class="s1">&#39;set! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obstacle_ids</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_obstacles_on_lanelet</span> <span class="o">=</span> <span class="n">obstacle_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stop_line</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StopLine</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span>

    <span class="nd">@stop_line</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stop_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stop_line</span><span class="p">:</span> <span class="n">StopLine</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop_line</span><span class="p">,</span> <span class="n">StopLine</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/stop_line&gt;: &#39;&#39;Provided type is not valid! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">stop_line</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span> <span class="o">=</span> <span class="n">stop_line</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lanelet_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">LaneletType</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_type</span>

    <span class="nd">@lanelet_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lanelet_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet_type</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">LaneletType</span><span class="p">]):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lanelet_type</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">LaneletType</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span>
                                                     <span class="n">lanelet_type</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/lanelet_type&gt;: &#39;&#39;Provided type is not &#39;</span> \
                                                                    <span class="s1">&#39;valid! type = </span><span class="si">{}</span><span class="s1">, &#39;</span> \
                                                                    <span class="s1">&#39;expected = Set[LaneletType]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">lanelet_type</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_type</span> <span class="o">=</span> <span class="n">lanelet_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_one_way</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">RoadUser</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_one_way</span>

    <span class="nd">@user_one_way</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user_one_way</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_one_way</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">RoadUser</span><span class="p">]):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_one_way</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">RoadUser</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span>
                                                     <span class="n">user_one_way</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/user_one_way&gt;: Provided type is not &#39;</span> \
                                                                    <span class="s1">&#39;valid! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">user_one_way</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_one_way</span> <span class="o">=</span> <span class="n">user_one_way</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_bidirectional</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">RoadUser</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_bidirectional</span>

    <span class="nd">@user_bidirectional</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user_bidirectional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_bidirectional</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">RoadUser</span><span class="p">]):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_bidirectional</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">RoadUser</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span>
                                                           <span class="n">user_bidirectional</span><span class="p">),</span> \
            <span class="s1">&#39;&lt;Lanelet/user_bidirectional&gt;: Provided type is not valid! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">user_bidirectional</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_bidirectional</span> <span class="o">=</span> <span class="n">user_bidirectional</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traffic_signs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span>

    <span class="nd">@traffic_signs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">traffic_signs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_sign_ids</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">traffic_sign_ids</span><span class="p">,</span> <span class="nb">set</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/traffic_signs&gt;: provided list of ids is not a &#39;</span> \
                                                  <span class="s1">&#39;set! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">traffic_sign_ids</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span> <span class="o">=</span> <span class="n">traffic_sign_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traffic_lights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span>

    <span class="nd">@traffic_lights</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">traffic_lights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_light_ids</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">traffic_light_ids</span><span class="p">,</span> <span class="nb">set</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/traffic_lights&gt;: provided list of ids is not a &#39;</span> \
                                                   <span class="s1">&#39;set! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">traffic_light_ids</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span> <span class="o">=</span> <span class="n">traffic_light_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polygon</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon</span>

<div class="viewcode-block" id="Lanelet.add_predecessor"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.add_predecessor">[docs]</a>    <span class="k">def</span> <span class="nf">add_predecessor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the ID of a predecessor lanelet to the list of predecessors.</span>
<span class="sd">        :param lanelet: Predecessor lanelet ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lanelet</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predecessor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lanelet</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.remove_predecessor"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.remove_predecessor">[docs]</a>    <span class="k">def</span> <span class="nf">remove_predecessor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the ID of a predecessor lanelet from the list of predecessors.</span>
<span class="sd">        :param lanelet: Predecessor lanelet ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lanelet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predecessor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">lanelet</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.add_successor"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.add_successor">[docs]</a>    <span class="k">def</span> <span class="nf">add_successor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the ID of a successor lanelet to the list of successors.</span>
<span class="sd">        :param lanelet: Successor lanelet ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lanelet</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">successor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lanelet</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.remove_successor"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.remove_successor">[docs]</a>    <span class="k">def</span> <span class="nf">remove_successor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the ID of a successor lanelet from the list of successors.</span>
<span class="sd">        :param lanelet: Successor lanelet ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lanelet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">successor</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">lanelet</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.translate_rotate"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.translate_rotate">[docs]</a>    <span class="k">def</span> <span class="nf">translate_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method translates and rotates a lanelet</span>

<span class="sd">        :param translation: The translation given as [x_off,y_off] for the x and y translation</span>
<span class="sd">        :param angle: The rotation angle in radian (counter-clockwise defined)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">is_real_number_vector</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/translate_rotate&gt;: provided translation &#39;</span> \
                                                      <span class="s1">&#39;is not valid! translation = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">is_valid_orientation</span><span class="p">(</span>
                <span class="n">angle</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/translate_rotate&gt;: provided angle is not valid! angle = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

        <span class="c1"># create transformation matrix</span>
        <span class="n">t_m</span> <span class="o">=</span> <span class="n">commonroad</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">translation_rotation_matrix</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="c1"># transform center vertices</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">t_m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))))</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># transform left vertices</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">t_m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">left_vertices</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))))</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># transform right vertices</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">t_m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">right_vertices</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))))</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># transform the stop line</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stop_line</span><span class="o">.</span><span class="n">translate_rotate</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

        <span class="c1"># recreate polygon in case it existed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">right_vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span></div>

<div class="viewcode-block" id="Lanelet.interpolate_position"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.interpolate_position">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the interpolated positions on the center/right/left polyline of the lanelet for a given distance</span>
<span class="sd">        along the lanelet</span>

<span class="sd">        :param distance: The distance for the interpolation</span>
<span class="sd">        :return: The interpolated positions on the center/right/left polyline and the segment id of the polyline where</span>
<span class="sd">            the interpolation takes place in the form ([x_c,y_c],[x_r,y_r],[x_l,y_l], segment_id)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_real_number</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">distance</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span>
                                                                                                               <span class="mi">0</span><span class="p">),</span> \
            <span class="s1">&#39;&lt;Lanelet/interpolate_position&gt;: provided distance is not valid! distance = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">distance</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_vertices</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_vertices</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_vertices</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.convert_to_polygon"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.convert_to_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polygon</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the given lanelet to a polygon representation</span>

<span class="sd">        :return: The polygon of the lanelet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Use the lanelet property &lt;polygon&gt; instead&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon</span></div>

<div class="viewcode-block" id="Lanelet.contains_points"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.contains_points">[docs]</a>    <span class="k">def</span> <span class="nf">contains_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point_list</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a list of points is enclosed in the lanelet</span>

<span class="sd">        :param point_list: The list of points in the form [[px1,py1],[px2,py2,],...]</span>
<span class="sd">        :return: List of Boolean values with True indicating point is enclosed and False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_list</span><span class="p">,</span>
                          <span class="n">ValidTypes</span><span class="o">.</span><span class="n">ARRAY</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/contains_points&gt;: provided list of points is not a list! type &#39;</span> \
                                             <span class="s1">&#39;= </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">point_list</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">is_valid_polyline</span><span class="p">(</span>
                <span class="n">point_list</span><span class="p">),</span> <span class="s1">&#39;Lanelet/contains_points&gt;: provided list of points is malformed! points = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">point_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygon</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">point_list</span><span class="p">]</span></div>

<div class="viewcode-block" id="Lanelet.get_obstacles"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.get_obstacles">[docs]</a>    <span class="k">def</span> <span class="nf">get_obstacles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Obstacle</span><span class="p">],</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Obstacle</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the subset of obstacles,  which are located in the lanelet,  of a given candidate set</span>

<span class="sd">        :param obstacles: The set of obstacle candidates</span>
<span class="sd">        :param time_step: The time step for the occupancy to check</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obstacles</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Obstacle</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obstacles</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/get_obstacles&gt;: Provided list of obstacles&#39;</span> \
                                                             <span class="s1">&#39; is malformed! obstacles = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obstacles</span><span class="p">)</span>

        <span class="c1"># output list</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">lanelet_shapely_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon</span><span class="o">.</span><span class="n">shapely_object</span>
        <span class="c1"># look at each obstacle</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obstacles</span><span class="p">:</span>
            <span class="n">o_shape</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">occupancy_at_time</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># vertices to check</span>
            <span class="n">shape_shapely_objects</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

            <span class="c1"># distinguish between shape and shape group and extract vertices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o_shape</span><span class="p">,</span> <span class="n">ShapeGroup</span><span class="p">):</span>
                <span class="n">shape_shapely_objects</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">sh</span><span class="o">.</span><span class="n">shapely_object</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">o_shape</span><span class="o">.</span><span class="n">shapes</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape_shapely_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o_shape</span><span class="o">.</span><span class="n">shapely_object</span><span class="p">)</span>

            <span class="c1"># check if obstacle is in lane</span>
            <span class="k">for</span> <span class="n">shapely_obj</span> <span class="ow">in</span> <span class="n">shape_shapely_objects</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lanelet_shapely_obj</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">shapely_obj</span><span class="p">):</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_merge_static_obstacles_on_lanelet</span><span class="p">(</span><span class="n">obstacles_on_lanelet1</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">obstacles_on_lanelet2</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges obstacle IDs of static obstacles on two lanelets</span>

<span class="sd">        :param obstacles_on_lanelet1: Obstacle IDs on the first lanelet</span>
<span class="sd">        :param obstacles_on_lanelet2: Obstacle IDs on the second lanelet</span>
<span class="sd">        :return: Merged obstacle IDs of static obstacles on lanelets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">obs_id</span> <span class="ow">in</span> <span class="n">obstacles_on_lanelet2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obs_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obstacles_on_lanelet1</span><span class="p">:</span>
                <span class="n">obstacles_on_lanelet1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obs_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obstacles_on_lanelet1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_merge_dynamic_obstacles_on_lanelet</span><span class="p">(</span><span class="n">obstacles_on_lanelet1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                                            <span class="n">obstacles_on_lanelet2</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges obstacle IDs of static obstacles on two lanelets</span>

<span class="sd">        :param obstacles_on_lanelet1: Obstacle IDs on the first lanelet</span>
<span class="sd">        :param obstacles_on_lanelet2: Obstacle IDs on the second lanelet</span>
<span class="sd">        :return: Merged obstacle IDs of static obstacles on lanelets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacles_on_lanelet2</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">obstacles_on_lanelet2</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">obs_id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">obstacles_on_lanelet1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">obs_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obstacles_on_lanelet1</span><span class="p">[</span><span class="n">time_step</span><span class="p">]:</span>
                            <span class="n">obstacles_on_lanelet1</span><span class="p">[</span><span class="n">time_step</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obs_id</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">obstacles_on_lanelet1</span><span class="p">[</span><span class="n">time_step</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">obs_id</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">obstacles_on_lanelet1</span>

<div class="viewcode-block" id="Lanelet.merge_lanelets"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.merge_lanelets">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge_lanelets</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lanelet1</span><span class="p">:</span> <span class="s1">&#39;Lanelet&#39;</span><span class="p">,</span> <span class="n">lanelet2</span><span class="p">:</span> <span class="s1">&#39;Lanelet&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Lanelet&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two lanelets which are in predecessor-successor relation</span>

<span class="sd">        :param lanelet1: The first lanelet</span>
<span class="sd">        :param lanelet2: The second lanelet</span>
<span class="sd">        :return: Merged lanelet (predecessor =&gt; successor)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lanelet1</span><span class="p">,</span> <span class="n">Lanelet</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/merge_lanelets&gt;: lanelet1 is not a valid lanelet object!&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lanelet2</span><span class="p">,</span> <span class="n">Lanelet</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/merge_lanelets&gt;: lanelet1 is not a valid lanelet object!&#39;</span>
        <span class="c1"># check connection via successor / predecessor</span>
        <span class="k">assert</span> <span class="n">lanelet1</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet2</span><span class="o">.</span><span class="n">successor</span> <span class="ow">or</span> \
               <span class="n">lanelet2</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet1</span><span class="o">.</span><span class="n">successor</span> <span class="ow">or</span> \
               <span class="n">lanelet1</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet2</span><span class="o">.</span><span class="n">predecessor</span> <span class="ow">or</span> \
               <span class="n">lanelet2</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet1</span><span class="o">.</span><span class="n">predecessor</span><span class="p">,</span> <span class="s1">&#39;&lt;Lanelet/merge_lanelets&gt;: cannot merge two not &#39;</span> \
                                                            <span class="s1">&#39;connected lanelets! successors of l1 = </span><span class="si">{}</span><span class="s1">, successors &#39;</span> \
                                                            <span class="s1">&#39;of l2 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lanelet1</span><span class="o">.</span><span class="n">successor</span><span class="p">,</span> <span class="n">lanelet2</span><span class="o">.</span><span class="n">successor</span><span class="p">)</span>

        <span class="c1"># check pred and successor</span>
        <span class="k">if</span> <span class="n">lanelet1</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet2</span><span class="o">.</span><span class="n">predecessor</span> <span class="ow">or</span> <span class="n">lanelet2</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet1</span><span class="o">.</span><span class="n">successor</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">lanelet1</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">lanelet2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">lanelet2</span>
            <span class="n">suc</span> <span class="o">=</span> <span class="n">lanelet1</span>

        <span class="c1"># build new merged lanelet (remove first node of successor if both lanes are connected)</span>
        <span class="c1"># check connectedness</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">suc</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># create new lanelet</span>
        <span class="n">left_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pred</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">,</span> <span class="n">suc</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">:]))</span>
        <span class="n">right_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pred</span><span class="o">.</span><span class="n">right_vertices</span><span class="p">,</span> <span class="n">suc</span><span class="o">.</span><span class="n">right_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">:]))</span>
        <span class="n">center_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pred</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">,</span> <span class="n">suc</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">:]))</span>
        <span class="n">lanelet_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">suc</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">))</span>
        <span class="n">predecessor</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">predecessor</span>
        <span class="n">successor</span> <span class="o">=</span> <span class="n">suc</span><span class="o">.</span><span class="n">successor</span>
        <span class="n">static_obstacles_on_lanelet</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_static_obstacles_on_lanelet</span><span class="p">(</span><span class="n">lanelet1</span><span class="o">.</span><span class="n">static_obstacles_on_lanelet</span><span class="p">,</span>
                                                                             <span class="n">lanelet2</span><span class="o">.</span><span class="n">static_obstacles_on_lanelet</span><span class="p">)</span>
        <span class="n">dynamic_obstacles_on_lanelet</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_dynamic_obstacles_on_lanelet</span><span class="p">(</span><span class="n">lanelet1</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span><span class="p">,</span>
                                                                               <span class="n">lanelet2</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span><span class="p">)</span>

        <span class="n">new_lanelet</span> <span class="o">=</span> <span class="n">Lanelet</span><span class="p">(</span><span class="n">left_vertices</span><span class="p">,</span> <span class="n">center_vertices</span><span class="p">,</span> <span class="n">right_vertices</span><span class="p">,</span> <span class="n">lanelet_id</span><span class="p">,</span> <span class="n">predecessor</span><span class="o">=</span><span class="n">predecessor</span><span class="p">,</span>
                              <span class="n">successor</span><span class="o">=</span><span class="n">successor</span><span class="p">)</span>
        <span class="n">new_lanelet</span><span class="o">.</span><span class="n">static_obstacles_on_lanelet</span> <span class="o">=</span> <span class="n">static_obstacles_on_lanelet</span>
        <span class="n">new_lanelet</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span> <span class="o">=</span> <span class="n">dynamic_obstacles_on_lanelet</span>
        <span class="k">return</span> <span class="n">new_lanelet</span></div>

<div class="viewcode-block" id="Lanelet.all_lanelets_by_merging_successors_from_lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.all_lanelets_by_merging_successors_from_lanelet">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">all_lanelets_by_merging_successors_from_lanelet</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lanelet</span><span class="p">:</span> <span class="s1">&#39;Lanelet&#39;</span><span class="p">,</span>
                                                        <span class="n">network</span><span class="p">:</span> <span class="s1">&#39;LaneletNetwork&#39;</span><span class="p">,</span> <span class="n">max_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">150.0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s1">&#39;Lanelet&#39;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes all reachable lanelets starting from a provided lanelet</span>
<span class="sd">        and merges them to a single lanelet for each route.</span>

<span class="sd">        :param lanelet: The lanelet to start from</span>
<span class="sd">        :param network: The network which contains all lanelets</span>
<span class="sd">        :param max_length: maximal length of merged lanelets can be provided</span>
<span class="sd">        :return: List of merged lanelets, Lists of lanelet ids of which each merged lanelet consists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lanelet</span><span class="p">,</span> <span class="n">Lanelet</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet&gt;: provided lanelet is not a valid Lanelet!&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">LaneletNetwork</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet&gt;: provided lanelet network is not a &#39;</span> \
                                                    <span class="s1">&#39;valid lanelet network!&#39;</span>
        <span class="k">assert</span> <span class="n">network</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&lt;Lanelet&gt;: lanelet not &#39;</span> \
                                                                           <span class="s1">&#39;contained in network!&#39;</span>

        <span class="k">if</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">successor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">successor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">lanelet</span><span class="p">],</span> <span class="p">[[</span><span class="n">lanelet</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">]]</span>

        <span class="n">merge_jobs</span> <span class="o">=</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">find_lanelet_successors_in_range</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">)</span>
        <span class="n">merge_jobs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lanelet</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">network</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">merge_jobs</span><span class="p">]</span>

        <span class="c1"># Create merged lanelets from paths</span>
        <span class="n">merged_lanelets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">merge_jobs_final</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">merge_jobs</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">merge_jobs_tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">pred</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">lanelet</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">merge_jobs_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">Lanelet</span><span class="o">.</span><span class="n">merge_lanelets</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">lanelet</span><span class="p">)</span>

            <span class="n">merge_jobs_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_jobs_tmp</span><span class="p">)</span>
            <span class="n">merged_lanelets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_lanelets</span><span class="p">,</span> <span class="n">merge_jobs_final</span></div>

<div class="viewcode-block" id="Lanelet.find_lanelet_successors_in_range"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.find_lanelet_successors_in_range">[docs]</a>    <span class="k">def</span> <span class="nf">find_lanelet_successors_in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet_network</span><span class="p">:</span> <span class="s2">&quot;LaneletNetwork&quot;</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mf">50.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all possible successor paths (id sequences) within max_length.</span>

<span class="sd">        :param lanelet_network: lanelet network</span>
<span class="sd">        :param max_length: abort once length of path is reached</span>
<span class="sd">        :return: list of lanelet IDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successor</span><span class="p">]</span>
        <span class="n">paths_final</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">lanelet_network</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">distance</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successor</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">paths_next</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lengths_next</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">le</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
                <span class="n">successors</span> <span class="o">=</span> <span class="n">lanelet_network</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">successor</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">successors</span><span class="p">:</span>
                    <span class="n">paths_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">successors</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">p</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">or</span> <span class="n">le</span> <span class="o">&gt;=</span> <span class="n">max_length</span><span class="p">:</span>
                            <span class="c1"># prevent loops and consider length of first successor</span>
                            <span class="n">paths_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                            <span class="k">continue</span>

                        <span class="n">l_next</span> <span class="o">=</span> <span class="n">le</span> <span class="o">+</span> <span class="n">lanelet_network</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">distance</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">l_next</span> <span class="o">&lt;</span> <span class="n">max_length</span><span class="p">:</span>
                            <span class="n">paths_next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span>
                            <span class="n">lengths_next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_next</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">paths_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span>

            <span class="n">paths</span> <span class="o">=</span> <span class="n">paths_next</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="n">lengths_next</span>

        <span class="k">return</span> <span class="n">paths_final</span></div>

<div class="viewcode-block" id="Lanelet.add_dynamic_obstacle_to_lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.add_dynamic_obstacle_to_lanelet">[docs]</a>    <span class="k">def</span> <span class="nf">add_dynamic_obstacle_to_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacle_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a dynamic obstacle ID to lanelet</span>

<span class="sd">        :param obstacle_id: obstacle ID to add</span>
<span class="sd">        :param time_step: time step at which the obstacle should be added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span><span class="p">[</span><span class="n">time_step</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span><span class="p">[</span><span class="n">time_step</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obstacle_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.add_static_obstacle_to_lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.add_static_obstacle_to_lanelet">[docs]</a>    <span class="k">def</span> <span class="nf">add_static_obstacle_to_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacle_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a static obstacle ID to lanelet</span>

<span class="sd">        :param obstacle_id: obstacle ID to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">static_obstacles_on_lanelet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obstacle_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.add_traffic_sign_to_lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.add_traffic_sign_to_lanelet">[docs]</a>    <span class="k">def</span> <span class="nf">add_traffic_sign_to_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_sign_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a traffic sign ID to lanelet</span>

<span class="sd">        :param traffic_sign_id: traffic sign ID to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traffic_signs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">traffic_sign_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.add_traffic_light_to_lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.add_traffic_light_to_lanelet">[docs]</a>    <span class="k">def</span> <span class="nf">add_traffic_light_to_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_light_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a traffic light ID to lanelet</span>

<span class="sd">        :param traffic_light_id: traffic light ID to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traffic_lights</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">traffic_light_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lanelet.dynamic_obstacle_by_time_step"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.dynamic_obstacle_by_time_step">[docs]</a>    <span class="k">def</span> <span class="nf">dynamic_obstacle_by_time_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all dynamic obstacles on lanelet at specific time step</span>

<span class="sd">        :param time_step: time step of interest</span>
<span class="sd">        :returns: list of obstacle IDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_obstacles_on_lanelet</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span></div>

<div class="viewcode-block" id="Lanelet.orientation_by_position"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.Lanelet.orientation_by_position">[docs]</a>    <span class="k">def</span> <span class="nf">orientation_by_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns lanelet orientation closest to a given position</span>
<span class="sd">        :param position: position of interest</span>
<span class="sd">        :return: orientation in interval [-pi,pi]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">check_angle</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">):</span>
            <span class="n">vector_1</span> <span class="o">=</span> <span class="n">point</span> <span class="o">-</span> <span class="n">point1</span>
            <span class="n">vector_2</span> <span class="o">=</span> <span class="n">point2</span> <span class="o">-</span> <span class="n">point1</span>

            <span class="k">def</span> <span class="nf">unit_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">vector</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">vector</span> <span class="o">/</span> <span class="n">norm</span>

            <span class="n">dot_product</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">vector_1</span><span class="p">),</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">vector_2</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">dot_product</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">check_angle</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">90</span> \
               <span class="ow">and</span> <span class="n">check_angle</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">90</span>
        <span class="n">position_diff_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span> <span class="o">-</span> <span class="n">position</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">closest_vertex_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">position_diff_square</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">closest_vertex_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vertex1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="n">closest_vertex_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">vertex2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="n">closest_vertex_index</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertex1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="n">closest_vertex_index</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">vertex2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_vertices</span><span class="p">[</span><span class="n">closest_vertex_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">direction_vector</span> <span class="o">=</span> <span class="n">vertex2</span> <span class="o">-</span> <span class="n">vertex1</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">direction_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="LaneletNetwork"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork">[docs]</a><span class="k">class</span> <span class="nc">LaneletNetwork</span><span class="p">(</span><span class="n">IDrawable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class which represents a network of connected lanelets</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for LaneletNetwork</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Lanelet</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># lanelet_id, shapely_polygon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_polygons</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ShapelyPolygon</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strtee</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># id(shapely_polygon), lanelet_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id_index_by_id</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">TrafficSign</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">TrafficLight</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># pickling of STRtree is not supported by shapely at the moment</span>
    <span class="c1"># use this workaround described in this issue:</span>
    <span class="c1"># https://github.com/Toblerity/Shapely/issues/1033</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_strtee&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="c1"># reset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strtee</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>

        <span class="n">result</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span>
        <span class="c1"># restore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LaneletNetwork</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality between LaneletNetwork </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and different type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">list_elements_eq</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">lanelet_network_eq</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">]</span>
        <span class="n">elements_other</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_lanelets</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_intersections</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">e_other</span> <span class="o">=</span> <span class="n">elements_other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lanelet_network_eq</span> <span class="o">=</span> <span class="n">lanelet_network_eq</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_other</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">e_other</span><span class="p">:</span>
                    <span class="n">lanelet_network_eq</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">e_other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">list_elements_eq</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">lanelet_network_eq</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality of LaneletNetwork </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and the other one </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lanelet_network_eq</span> <span class="ow">and</span> <span class="n">list_elements_eq</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
                     <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;LaneletNetwork consists of lanelets </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;intersections </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;traffic signs </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">, and traffic lights </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;LaneletNetwork(lanelets=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="p">)</span><span class="si">}</span><span class="s2">, intersections=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span> \
               <span class="sa">f</span><span class="s2">&quot;traffic_signs=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">)</span><span class="si">}</span><span class="s2">, traffic_lights=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">_get_lanelet_id_by_shapely_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">ShapelyPolygon</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id_index_by_id</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">polygon</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lanelets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Lanelet</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lanelet_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">la</span><span class="o">.</span><span class="n">polygon</span> <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lanelets</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Intersection</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traffic_signs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TrafficSign</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traffic_lights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TrafficLight</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">map_inc_lanelets_to_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: dict that maps lanelet ids to the intersection of which it is an incoming lanelet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">l_id</span><span class="p">:</span> <span class="n">intersection</span> <span class="k">for</span> <span class="n">intersection</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span> <span class="k">for</span> <span class="n">l_id</span> <span class="ow">in</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">intersection</span><span class="o">.</span><span class="n">map_incoming_lanelets</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>

<div class="viewcode-block" id="LaneletNetwork.create_from_lanelet_list"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.create_from_lanelet_list">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_from_lanelet_list</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lanelets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">cleanup_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a LaneletNetwork object from a given list of lanelets</span>

<span class="sd">        :param lanelets: The list of lanelets</span>
<span class="sd">        :param cleanup_ids: cleans up unused ids</span>
<span class="sd">        :return: The LaneletNetwork for the given list of lanelets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lanelets</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">la</span><span class="p">,</span> <span class="n">Lanelet</span><span class="p">)</span> <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">lanelets</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/create_from_lanelet_list&gt;:&#39;</span> \
                                                             <span class="s1">&#39;Provided list of lanelets is not valid! &#39;</span> \
                                                             <span class="s1">&#39;lanelets = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lanelets</span><span class="p">)</span>

        <span class="c1"># create lanelet network</span>
        <span class="n">lanelet_network</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="c1"># add each lanelet to the lanelet network</span>
        <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">lanelets</span><span class="p">:</span>
            <span class="n">lanelet_network</span><span class="o">.</span><span class="n">add_lanelet</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">la</span><span class="p">),</span> <span class="n">rtree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cleanup_ids</span><span class="p">:</span>
            <span class="n">lanelet_network</span><span class="o">.</span><span class="n">cleanup_lanelet_references</span><span class="p">()</span>

        <span class="n">lanelet_network</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lanelet_network</span></div>

<div class="viewcode-block" id="LaneletNetwork.create_from_lanelet_network"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.create_from_lanelet_network">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_from_lanelet_network</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lanelet_network</span><span class="p">:</span> <span class="s1">&#39;LaneletNetwork&#39;</span><span class="p">,</span> <span class="n">shape_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">exclude_lanelet_types</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a lanelet network from a given lanelet network (copy); adding a shape reduces the lanelets to those</span>
<span class="sd">        that intersect the shape provided and specifying a lanelet_type set excludes the lanelet types in the new</span>
<span class="sd">        created network.</span>

<span class="sd">        :param lanelet_network: The existing lanelet network</span>
<span class="sd">        :param shape_input: The lanelets intersecting this shape will be in the new network</span>
<span class="sd">        :param exclude_lanelet_types: Removes all lanelets with these lanelet_types</span>
<span class="sd">        :return: The new lanelet network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_lanelet_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_lanelet_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">new_lanelet_network</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">traffic_sign_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">traffic_light_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">lanelets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">shape_input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">lanelet_network</span><span class="o">.</span><span class="n">lanelets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">lanelet_type</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">exclude_lanelet_types</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
                    <span class="n">lanelet_polygon</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="n">shapely_object</span>
                    <span class="k">if</span> <span class="n">shape_input</span><span class="o">.</span><span class="n">shapely_object</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">lanelet_polygon</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">sign_id</span> <span class="ow">in</span> <span class="n">la</span><span class="o">.</span><span class="n">traffic_signs</span><span class="p">:</span>
                            <span class="n">traffic_sign_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sign_id</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">light_id</span> <span class="ow">in</span> <span class="n">la</span><span class="o">.</span><span class="n">traffic_lights</span><span class="p">:</span>
                            <span class="n">traffic_light_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">light_id</span><span class="p">)</span>
                        <span class="n">lanelets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">la</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">lanelet_network</span><span class="o">.</span><span class="n">lanelets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">lanelet_type</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">exclude_lanelet_types</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
                    <span class="n">lanelets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">la</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sign_id</span> <span class="ow">in</span> <span class="n">la</span><span class="o">.</span><span class="n">traffic_signs</span><span class="p">:</span>
                    <span class="n">traffic_sign_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sign_id</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">light_id</span> <span class="ow">in</span> <span class="n">la</span><span class="o">.</span><span class="n">traffic_lights</span><span class="p">:</span>
                    <span class="n">traffic_light_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">light_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sign_id</span> <span class="ow">in</span> <span class="n">traffic_sign_ids</span><span class="p">:</span>
            <span class="n">new_lanelet_network</span><span class="o">.</span><span class="n">add_traffic_sign</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">lanelet_network</span><span class="o">.</span><span class="n">find_traffic_sign_by_id</span><span class="p">(</span><span class="n">sign_id</span><span class="p">)),</span> <span class="nb">set</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">light_id</span> <span class="ow">in</span> <span class="n">traffic_light_ids</span><span class="p">:</span>
            <span class="n">new_lanelet_network</span><span class="o">.</span><span class="n">add_traffic_light</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">lanelet_network</span><span class="o">.</span><span class="n">find_traffic_light_by_id</span><span class="p">(</span><span class="n">light_id</span><span class="p">)),</span>
                                                  <span class="nb">set</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">lanelets</span><span class="p">:</span>
            <span class="n">new_lanelet_network</span><span class="o">.</span><span class="n">add_lanelet</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">la</span><span class="p">),</span> <span class="n">rtree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_lanelet_network</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">new_lanelet_network</span></div>

    <span class="k">def</span> <span class="nf">_create_strtree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates spatial index for lanelets for faster querying the lanelets by position.</span>

<span class="sd">        Since it is an immutable object, it has to be recreated after every lanelet addition or it should be done</span>
<span class="sd">        once after all lanelets are added.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># validate buffered polygons</span>
        <span class="k">def</span> <span class="nf">assert_shapely_polygon</span><span class="p">(</span><span class="n">lanelet_id</span><span class="p">,</span> <span class="n">polygon</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">ShapelyPolygon</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Lanelet with id </span><span class="si">{</span><span class="n">lanelet_id</span><span class="si">}</span><span class="s2">&#39;s polygon is not a &lt;shapely.geometry.Polygon&gt; object! It will &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;be OMITTED from STRtree, therefore this lanelet will NOT be contained in the results of the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;find_lanelet_by_&lt;position/shape&gt;() functions!!&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_polygons</span> <span class="o">=</span> <span class="p">{</span><span class="n">lanelet_id</span><span class="p">:</span> <span class="n">lanelet_shapely_polygon</span> <span class="k">for</span> <span class="n">lanelet_id</span><span class="p">,</span> <span class="n">lanelet_shapely_polygon</span> <span class="ow">in</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                                   <span class="n">assert_shapely_polygon</span><span class="p">(</span><span class="n">lanelet_id</span><span class="p">,</span> <span class="n">lanelet_shapely_polygon</span><span class="p">)}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lanelet_id_index_by_id</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">lanelet_shapely_polygon</span><span class="p">):</span> <span class="n">lanelet_id</span> <span class="k">for</span> <span class="n">lanelet_id</span><span class="p">,</span> <span class="n">lanelet_shapely_polygon</span>
                                        <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strtee</span> <span class="o">=</span> <span class="n">STRtree</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffered_polygons</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

<div class="viewcode-block" id="LaneletNetwork.remove_lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.remove_lanelet">[docs]</a>    <span class="k">def</span> <span class="nf">remove_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rtree</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a lanelet from a lanelet network and deletes all references.</span>

<span class="sd">        @param lanelet_id: ID of lanelet which should be removed.</span>
<span class="sd">        @param rtree: Boolean indicating whether rtree should be initialized</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lanelet_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="p">[</span><span class="n">lanelet_id</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_polygons</span><span class="p">[</span><span class="n">lanelet_id</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_lanelet_references</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rtree</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span></div>

<div class="viewcode-block" id="LaneletNetwork.cleanup_lanelet_references"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.cleanup_lanelet_references">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup_lanelet_references</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes lanelet IDs which do not exist in the lanelet network. Useful when cutting out lanelet networks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existing_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lanelets</span><span class="p">:</span>
            <span class="n">la</span><span class="o">.</span><span class="n">_predecessor</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">predecessor</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">))</span>
            <span class="n">la</span><span class="o">.</span><span class="n">_successor</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">successor</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">))</span>
            <span class="n">la</span><span class="o">.</span><span class="n">_adj_left</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_left</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_ids</span> <span class="k">else</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_left</span>

            <span class="n">la</span><span class="o">.</span><span class="n">_adj_left_same_direction</span> <span class="o">=</span> <span class="kc">None</span> \
                <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_left_same_direction</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_left</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_ids</span> <span class="k">else</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_left_same_direction</span>
            <span class="n">la</span><span class="o">.</span><span class="n">_adj_right</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_right</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_right</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_ids</span> <span class="k">else</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_right</span>
            <span class="n">la</span><span class="o">.</span><span class="n">_adj_right_same_direction</span> <span class="o">=</span> <span class="kc">None</span> \
                <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_right_same_direction</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">la</span><span class="o">.</span><span class="n">adj_right</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_ids</span> <span class="k">else</span> \
                <span class="n">la</span><span class="o">.</span><span class="n">adj_right_same_direction</span>

        <span class="k">for</span> <span class="n">inter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">inc</span> <span class="ow">in</span> <span class="n">inter</span><span class="o">.</span><span class="n">incomings</span><span class="p">:</span>
                <span class="n">inc</span><span class="o">.</span><span class="n">_incoming_lanelets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inc</span><span class="o">.</span><span class="n">incoming_lanelets</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span>
                <span class="n">inc</span><span class="o">.</span><span class="n">_successors_straight</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inc</span><span class="o">.</span><span class="n">successors_straight</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span>
                <span class="n">inc</span><span class="o">.</span><span class="n">_successors_right</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inc</span><span class="o">.</span><span class="n">successors_right</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span>
                <span class="n">inc</span><span class="o">.</span><span class="n">_successors_left</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inc</span><span class="o">.</span><span class="n">successors_left</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span>
            <span class="n">inter</span><span class="o">.</span><span class="n">_crossings</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inter</span><span class="o">.</span><span class="n">crossings</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span></div>

<div class="viewcode-block" id="LaneletNetwork.remove_traffic_sign"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.remove_traffic_sign">[docs]</a>    <span class="k">def</span> <span class="nf">remove_traffic_sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_sign_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a traffic sign from a lanelet network and deletes all references.</span>

<span class="sd">        @param traffic_sign_id: ID of traffic sign which should be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traffic_sign_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">[</span><span class="n">traffic_sign_id</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_traffic_sign_references</span><span class="p">()</span></div>

<div class="viewcode-block" id="LaneletNetwork.cleanup_traffic_sign_references"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.cleanup_traffic_sign_references">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup_traffic_sign_references</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes traffic sign IDs which do not exist in the lanelet network. Useful when cutting out lanelet networks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existing_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lanelets</span><span class="p">:</span>
            <span class="n">la</span><span class="o">.</span><span class="n">_traffic_signs</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">traffic_signs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span><span class="o">.</span><span class="n">traffic_sign_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span><span class="o">.</span><span class="n">_traffic_sign_ref</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span><span class="o">.</span><span class="n">traffic_sign_ref</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span></div>

<div class="viewcode-block" id="LaneletNetwork.remove_traffic_light"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.remove_traffic_light">[docs]</a>    <span class="k">def</span> <span class="nf">remove_traffic_light</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_light_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a traffic light from a lanelet network and deletes all references.</span>

<span class="sd">        @param traffic_light_id: ID of traffic sign which should be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traffic_light_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">[</span><span class="n">traffic_light_id</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_traffic_light_references</span><span class="p">()</span></div>

<div class="viewcode-block" id="LaneletNetwork.cleanup_traffic_light_references"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.cleanup_traffic_light_references">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup_traffic_light_references</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes traffic light IDs which do not exist in the lanelet network. Useful when cutting out lanelet networks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existing_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lanelets</span><span class="p">:</span>
            <span class="n">la</span><span class="o">.</span><span class="n">_traffic_lights</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">traffic_lights</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span><span class="o">.</span><span class="n">traffic_light_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span><span class="o">.</span><span class="n">_traffic_light_ref</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">stop_line</span><span class="o">.</span><span class="n">traffic_light_ref</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">existing_ids</span><span class="p">)</span></div>

<div class="viewcode-block" id="LaneletNetwork.remove_intersection"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.remove_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">remove_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intersection_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a intersection from a lanelet network and deletes all references.</span>

<span class="sd">        @param intersection_id: ID of intersection which should be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intersection_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="p">[</span><span class="n">intersection_id</span><span class="p">]</span></div>

<div class="viewcode-block" id="LaneletNetwork.find_lanelet_by_id"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.find_lanelet_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">find_lanelet_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Lanelet</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a lanelet for a given lanelet_id</span>

<span class="sd">        :param lanelet_id: The id of the lanelet to find</span>
<span class="sd">        :return: The lanelet object if the id exists and None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_natural_number</span><span class="p">(</span>
                <span class="n">lanelet_id</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/find_lanelet_by_id&gt;: provided id is not valid! id = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lanelet_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="p">[</span><span class="n">lanelet_id</span><span class="p">]</span> <span class="k">if</span> <span class="n">lanelet_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LaneletNetwork.find_traffic_sign_by_id"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.find_traffic_sign_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">find_traffic_sign_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_sign_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrafficSign</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a traffic sign for a given traffic_sign_id</span>

<span class="sd">        :param traffic_sign_id: The id of the traffic sign to find</span>
<span class="sd">        :return: The traffic sign object if the id exists and None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_natural_number</span><span class="p">(</span>
                <span class="n">traffic_sign_id</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/find_traffic_sign_by_id&gt;: provided id is not valid! &#39;</span> \
                                  <span class="s1">&#39;id = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traffic_sign_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">[</span><span class="n">traffic_sign_id</span><span class="p">]</span> <span class="k">if</span> <span class="n">traffic_sign_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LaneletNetwork.find_traffic_light_by_id"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.find_traffic_light_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">find_traffic_light_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_light_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrafficLight</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a traffic light for a given traffic_light_id</span>

<span class="sd">        :param traffic_light_id: The id of the traffic light to find</span>
<span class="sd">        :return: The traffic light object if the id exists and None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_natural_number</span><span class="p">(</span>
                <span class="n">traffic_light_id</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/find_traffic_light_by_id&gt;: provided id is not valid! &#39;</span> \
                                   <span class="s1">&#39;id = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traffic_light_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">[</span><span class="n">traffic_light_id</span><span class="p">]</span> <span class="k">if</span> <span class="n">traffic_light_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LaneletNetwork.find_intersection_by_id"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.find_intersection_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">find_intersection_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intersection_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Intersection</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a intersection for a given intersection_id</span>

<span class="sd">        :param intersection_id: The id of the intersection to find</span>
<span class="sd">        :return: The intersection object if the id exists and None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_natural_number</span><span class="p">(</span><span class="n">intersection_id</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/find_intersection_by_id&gt;: &#39;</span> \
                                                   <span class="s1">&#39;provided id is not valid! id = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">intersection_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="p">[</span><span class="n">intersection_id</span><span class="p">]</span> <span class="k">if</span> <span class="n">intersection_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LaneletNetwork.add_lanelet"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.add_lanelet">[docs]</a>    <span class="k">def</span> <span class="nf">add_lanelet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet</span><span class="p">:</span> <span class="n">Lanelet</span><span class="p">,</span> <span class="n">rtree</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a lanelet to the LaneletNetwork</span>

<span class="sd">        :param lanelet: The lanelet to add</span>
<span class="sd">        :param rtree: Boolean indicating whether rtree should be initialized</span>
<span class="sd">        :return: True if the lanelet has successfully been added to the network, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lanelet</span><span class="p">,</span> <span class="n">Lanelet</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/add_lanelet&gt;: provided lanelet is not of &#39;</span> \
                                             <span class="s1">&#39;type lanelet! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lanelet</span><span class="p">))</span>

        <span class="c1"># check if lanelet already exists in network and warn user</span>
        <span class="k">if</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">lanelet_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Lanelet already exists in network! No changes are made.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="p">[</span><span class="n">lanelet</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">lanelet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_polygons</span><span class="p">[</span><span class="n">lanelet</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="n">shapely_object</span>
            <span class="k">if</span> <span class="n">rtree</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LaneletNetwork.add_traffic_sign"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.add_traffic_sign">[docs]</a>    <span class="k">def</span> <span class="nf">add_traffic_sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_sign</span><span class="p">:</span> <span class="n">TrafficSign</span><span class="p">,</span> <span class="n">lanelet_ids</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a traffic sign to the LaneletNetwork</span>

<span class="sd">        :param traffic_sign: The traffic sign to add</span>
<span class="sd">        :param lanelet_ids: Lanelets the traffic sign should be referenced from</span>
<span class="sd">        :return: True if the traffic sign has successfully been added to the network, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">traffic_sign</span><span class="p">,</span> <span class="n">TrafficSign</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/add_traffic_sign&gt;: provided traffic sign is &#39;</span> \
                                                      <span class="s1">&#39;not of type traffic_sign! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">traffic_sign</span><span class="p">))</span>

        <span class="c1"># check if traffic already exists in network and warn user</span>
        <span class="k">if</span> <span class="n">traffic_sign</span><span class="o">.</span><span class="n">traffic_sign_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Traffic sign with ID </span><span class="si">{}</span><span class="s1"> already exists in network! &#39;</span>
                          <span class="s1">&#39;No changes are made.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traffic_sign</span><span class="o">.</span><span class="n">traffic_sign_id</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="p">[</span><span class="n">traffic_sign</span><span class="o">.</span><span class="n">traffic_sign_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">traffic_sign</span>
            <span class="k">for</span> <span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet_ids</span><span class="p">:</span>
                <span class="n">lanelet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">lanelet_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lanelet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lanelet</span><span class="o">.</span><span class="n">add_traffic_sign_to_lanelet</span><span class="p">(</span><span class="n">traffic_sign</span><span class="o">.</span><span class="n">traffic_sign_id</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Traffic sign cannot be referenced to lanelet because the lanelet does not exist.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LaneletNetwork.add_traffic_light"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.add_traffic_light">[docs]</a>    <span class="k">def</span> <span class="nf">add_traffic_light</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traffic_light</span><span class="p">:</span> <span class="n">TrafficLight</span><span class="p">,</span> <span class="n">lanelet_ids</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a traffic light to the LaneletNetwork</span>

<span class="sd">        :param traffic_light: The traffic light to add</span>
<span class="sd">        :param lanelet_ids: Lanelets the traffic sign should be referenced from</span>
<span class="sd">        :return: True if the traffic light has successfully been added to the network, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">traffic_light</span><span class="p">,</span> <span class="n">TrafficLight</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/add_traffic_light&gt;: provided traffic light &#39;</span> \
                                                        <span class="s1">&#39;is not of type traffic_light! &#39;</span> \
                                                        <span class="s1">&#39;type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">traffic_light</span><span class="p">))</span>

        <span class="c1"># check if traffic already exists in network and warn user</span>
        <span class="k">if</span> <span class="n">traffic_light</span><span class="o">.</span><span class="n">traffic_light_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Traffic light already exists in network! No changes are made.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="p">[</span><span class="n">traffic_light</span><span class="o">.</span><span class="n">traffic_light_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">traffic_light</span>
            <span class="k">for</span> <span class="n">lanelet_id</span> <span class="ow">in</span> <span class="n">lanelet_ids</span><span class="p">:</span>
                <span class="n">lanelet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">lanelet_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lanelet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lanelet</span><span class="o">.</span><span class="n">add_traffic_light_to_lanelet</span><span class="p">(</span><span class="n">traffic_light</span><span class="o">.</span><span class="n">traffic_light_id</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Traffic light cannot be referenced to lanelet because the lanelet does not exist.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LaneletNetwork.add_intersection"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.add_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">add_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intersection</span><span class="p">:</span> <span class="n">Intersection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an intersection to the LaneletNetwork</span>

<span class="sd">        :param intersection: The intersection to add</span>
<span class="sd">        :return: True if the traffic light has successfully been added to the network, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/add_intersection&gt;: provided intersection is &#39;</span> \
                                                       <span class="s1">&#39;not of type Intersection! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">intersection</span><span class="p">))</span>

        <span class="c1"># check if traffic already exists in network and warn user</span>
        <span class="k">if</span> <span class="n">intersection</span><span class="o">.</span><span class="n">intersection_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Intersection already exists in network! No changes are made.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intersections</span><span class="p">[</span><span class="n">intersection</span><span class="o">.</span><span class="n">intersection_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">intersection</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LaneletNetwork.add_lanelets_from_network"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.add_lanelets_from_network">[docs]</a>    <span class="k">def</span> <span class="nf">add_lanelets_from_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet_network</span><span class="p">:</span> <span class="s1">&#39;LaneletNetwork&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds lanelets from a given network object to the current network</span>

<span class="sd">        :param lanelet_network: The lanelet network</span>
<span class="sd">        :return: True if all lanelets have been added to the network, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># add lanelets to the network</span>
        <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">lanelet_network</span><span class="o">.</span><span class="n">lanelets</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lanelet</span><span class="p">(</span><span class="n">la</span><span class="p">,</span> <span class="n">rtree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_strtree</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">flag</span></div>

<div class="viewcode-block" id="LaneletNetwork.translate_rotate"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.translate_rotate">[docs]</a>    <span class="k">def</span> <span class="nf">translate_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translates and rotates the complete lanelet network</span>

<span class="sd">        :param translation: The translation given as [x_off,y_off] for the x and y translation</span>
<span class="sd">        :param angle: The rotation angle in radian (counter-clockwise defined)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">is_real_number_vector</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span>
                                     <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/translate_rotate&gt;: provided translation is not valid! &#39;</span> \
                                         <span class="s1">&#39;translation = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">is_valid_orientation</span><span class="p">(</span>
                <span class="n">angle</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/translate_rotate&gt;: provided angle is not valid! angle = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

        <span class="c1"># rotate each lanelet</span>
        <span class="k">for</span> <span class="n">lanelet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">lanelet</span><span class="o">.</span><span class="n">translate_rotate</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">traffic_sign</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_signs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">traffic_sign</span><span class="o">.</span><span class="n">translate_rotate</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">traffic_light</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_lights</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">traffic_light</span><span class="o">.</span><span class="n">translate_rotate</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span></div>

<div class="viewcode-block" id="LaneletNetwork.find_lanelet_by_position"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.find_lanelet_by_position">[docs]</a>    <span class="k">def</span> <span class="nf">find_lanelet_by_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the lanelet id of a given position</span>

<span class="sd">        :param point_list: The list of positions to check</span>
<span class="sd">        :return: A list of lanelet ids. If the position could not be matched to a lanelet, an empty list is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_list</span><span class="p">,</span>
                          <span class="n">ValidTypes</span><span class="o">.</span><span class="n">LISTS</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/contains_points&gt;: provided list of points is not a list! type &#39;</span> \
                                             <span class="s1">&#39;= </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">point_list</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lanelet_id_by_shapely_polygon</span><span class="p">(</span><span class="n">lanelet_shapely_polygon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lanelet_shapely_polygon</span> <span class="ow">in</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_strtee</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">if</span>
                 <span class="n">lanelet_shapely_polygon</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lanelet_shapely_polygon</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1e-15</span><span class="p">)</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">point</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ShapelyPoint</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">point_list</span><span class="p">]]</span></div>

<div class="viewcode-block" id="LaneletNetwork.find_lanelet_by_shape"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.find_lanelet_by_shape">[docs]</a>    <span class="k">def</span> <span class="nf">find_lanelet_by_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the lanelet id of a given shape</span>

<span class="sd">        :param shape: The shape to check</span>
<span class="sd">        :return: A list of lanelet ids. If the position could not be matched to a lanelet, an empty list is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">Circle</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">)),</span> <span class="s1">&#39;&lt;Lanelet/find_lanelet_by_shape&gt;: &#39;</span> \
                                                                <span class="s1">&#39;provided shape is not a shape! &#39;</span> \
                                                                <span class="s1">&#39;type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lanelet_id_by_shapely_polygon</span><span class="p">(</span><span class="n">lanelet_shapely_polygon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lanelet_shapely_polygon</span> <span class="ow">in</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_strtee</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">shapely_object</span><span class="p">)</span> <span class="k">if</span> <span class="n">lanelet_shapely_polygon</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">shapely_object</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="nf">_sorted_lanelet_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanelet_ids</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lanelet_ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lanelet_ids</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lanelet_id_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lanelet_ids</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">compute_lanelet_relative_orientation</span><span class="p">(</span><span class="n">lanelet_id</span><span class="p">):</span>
                <span class="n">lanelet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">lanelet_id</span><span class="p">)</span>
                <span class="n">lanelet_orientation</span> <span class="o">=</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">orientation_by_position</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">subtract_orientations</span><span class="p">(</span><span class="n">lanelet_orientation</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">orientation</span><span class="p">))</span>

            <span class="n">orientation_differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">compute_lanelet_relative_orientation</span><span class="p">,</span> <span class="n">lanelet_id_list</span><span class="p">)))</span>
            <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">orientation_differences</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">lanelet_id_list</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">])</span>

<div class="viewcode-block" id="LaneletNetwork.find_most_likely_lanelet_by_state"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.find_most_likely_lanelet_by_state">[docs]</a>    <span class="k">def</span> <span class="nf">find_most_likely_lanelet_by_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TraceState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the lanelet id of the position of a given state; in case of multiple overlapping lanelets, return the most</span>
<span class="sd">        likely lanelet according to the orientation difference between lanelets and given state</span>

<span class="sd">        :param state_list: The list of states to check</span>
<span class="sd">        :return: A list of lanelet ids. If the position could not be matched to a lanelet, an empty list is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_list</span><span class="p">,</span> <span class="n">ValidTypes</span><span class="o">.</span><span class="n">LISTS</span><span class="p">),</span> <span class="s1">&#39;&lt;Lanelet/find_most_likely_lanelet_by_state&gt;: &#39;</span> \
                                                         <span class="s1">&#39;provided list of points is not a list! type = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">state_list</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s2">&quot;orientation&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span>
                       <span class="n">state_list</span><span class="p">]),</span> <span class="s1">&#39;&lt;Lanelet/find_most_likely_lanelet_by_state&gt;: provided state must have &#39;</span> \
                                     <span class="s1">&#39;orientation!&#39;</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sorted_lanelet_ids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_position</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">state</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span>
                <span class="n">state_list</span><span class="p">]</span></div>

<div class="viewcode-block" id="LaneletNetwork.filter_obstacles_in_network"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.filter_obstacles_in_network">[docs]</a>    <span class="k">def</span> <span class="nf">filter_obstacles_in_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Obstacle</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Obstacle</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of obstacles which are located in the lanelet network</span>

<span class="sd">        :param obstacles: The list of obstacles to check</span>
<span class="sd">        :return: The list of obstacles which are located in the lanelet network</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">obstacle_to_lanelet_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_obstacles_to_lanelets</span><span class="p">(</span><span class="n">obstacles</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obstacle_to_lanelet_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="n">obstacle_to_lanelet_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="LaneletNetwork.map_obstacles_to_lanelets"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.map_obstacles_to_lanelets">[docs]</a>    <span class="k">def</span> <span class="nf">map_obstacles_to_lanelets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Obstacle</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Obstacle</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps a given list of obstacles to the lanelets of the lanelet network</span>

<span class="sd">        :param obstacles: The list of CR obstacles</span>
<span class="sd">        :return: A dictionary with the lanelet id as key and the list of obstacles on the lanelet as a List[Obstacles]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lanelets</span><span class="p">:</span>
            <span class="c1"># map obstacles to current lanelet</span>
            <span class="n">mapped_objs</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">get_obstacles</span><span class="p">(</span><span class="n">obstacles</span><span class="p">)</span>

            <span class="c1"># check if mapping is not empty</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapped_objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">la</span><span class="o">.</span><span class="n">lanelet_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_objs</span>

        <span class="k">return</span> <span class="n">mapping</span></div>

<div class="viewcode-block" id="LaneletNetwork.lanelets_in_proximity"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.lanelets_in_proximity">[docs]</a>    <span class="k">def</span> <span class="nf">lanelets_in_proximity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Lanelet</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all lanelets which intersect a given circle, defined by the center point and radius</span>

<span class="sd">        :param point: The center of the circle</span>
<span class="sd">        :param radius: The radius of the circle</span>
<span class="sd">        :return: The list of lanelets which intersect the given circle</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">is_real_number_vector</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/lanelets_in_proximity&gt;: provided point is &#39;</span> \
                                                       <span class="s1">&#39;not valid! point = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">is_positive</span><span class="p">(</span>
                <span class="n">radius</span><span class="p">),</span> <span class="s1">&#39;&lt;LaneletNetwork/lanelets_in_proximity&gt;: provided radius is not valid! radius = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">radius</span><span class="p">)</span>

        <span class="c1"># get list of lanelet ids</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lanelets</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># output list</span>
        <span class="n">lanes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">rad_sqr</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># distance dict for sorting</span>
        <span class="n">distance_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># go through list of lanelets</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>

            <span class="c1"># if current lanelet has not already been added to lanes list</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lanes</span><span class="p">:</span>
                <span class="n">lanelet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># compute distances (we are not using the sqrt for computational effort)</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">center_vertices</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">distance</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># check if at least one distance is smaller than the radius</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">rad_sqr</span><span class="p">,</span> <span class="n">distance</span><span class="p">)):</span>
                    <span class="n">lanes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">distance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distance</span><span class="p">))</span>

                <span class="c1"># check if adjacent lanelets can be added as well</span>
                <span class="n">index_min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="n">rad_sqr</span><span class="p">)</span>

                <span class="c1"># check right side of lanelet</span>
                <span class="k">if</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">adj_right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">right_vertices</span><span class="p">[</span><span class="n">index_min_dist</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">rad_sqr</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">adj_right</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lanes</span><span class="p">:</span>
                        <span class="n">lanes</span><span class="p">[</span><span class="n">lanelet</span><span class="o">.</span><span class="n">adj_right</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">adj_right</span><span class="p">)</span>
                        <span class="n">distance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

                <span class="c1"># check left side of lanelet</span>
                <span class="k">if</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">adj_left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">left_vertices</span><span class="p">[</span><span class="n">index_min_dist</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">rad_sqr</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lanelet</span><span class="o">.</span><span class="n">adj_left</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lanes</span><span class="p">:</span>
                        <span class="n">lanes</span><span class="p">[</span><span class="n">lanelet</span><span class="o">.</span><span class="n">adj_left</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_lanelet_by_id</span><span class="p">(</span><span class="n">lanelet</span><span class="o">.</span><span class="n">adj_left</span><span class="p">)</span>
                        <span class="n">distance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># sort list according to distance</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distance_list</span><span class="p">)</span>
        <span class="n">lanelets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lanes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># return sorted list</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">lanelets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>

<div class="viewcode-block" id="LaneletNetwork.draw"><a class="viewcode-back" href="../../../api/scenario.html#commonroad.scenario.lanelet.LaneletNetwork.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">:</span> <span class="n">IRenderer</span><span class="p">,</span> <span class="n">draw_params</span><span class="p">:</span> <span class="n">OptionalSpecificOrAllDrawParams</span><span class="p">[</span><span class="n">LaneletNetworkParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">draw_lanelet_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw_params</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Moritz Klischat, Sebastian Maierhofer, Stefanie Manzinger, Christian Pek, Luis Gressenbuch, Anna-Katharina Rettinger.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>